## Author - wMiu

### 数据类型
数据类型决定了程序中数据和操作的意义。
#### 内置类型
1. C++定义了一套包括 **算数类型**（arithmetic type）和**空类型**（void）在内的基本数据类型。
2. 其中空类型不对应具体的值，仅用于一些特殊场合。如，当函数不返回任何值时，使用空类型作为返回类型。

##### 算数类型
1. 算术类型分为两种**整型**（integral type）与**浮点型**
2. 其中整型包括字符类型和浮点型。

可以使用`sizeof()`函数来看数据类型所占用字节数。（程序：DataType.cpp）

- 布尔类型的取值为真(true)与假(false)

- 浮点型可以表示单精度 ，双精度和扩展精度值。

##### 带符号类型和无符号类型
除了布尔值和扩展字符型之外，其他整型可以划分为**带符号**（signed）和 **无符号**（unsigned）。
- 默认的数字类型都是带符号的，如果要使用无符号需要在类型前面加上 unsigned 如`unsigned short` ，其中 int 型，无符号可以简写为, `unsigned`。
- 字符类型被分为了三种，char ，signed char ，unsigned char。
   - char 与 signed char 并不同。
   - 尽管字符型有三种，但表现形式却只有两种，有符号的与无符号的，而具体为哪一种由编译器来决定。

##### 类型转换
对象的类型定义了对象能包含的数据和能参与的运算，其中一种运算被大多数的类型支持，数据类型转换，就是将对象从一种给定的类型**转换**（convert）为另一种相关的类型。

#### 字面值
字面值常量（literal）是固定值，在程序的执行过程中不会改变。

##### 整型和浮点型字面值
- 在C++中可以将整型字面值写为十进制、八进制或十六进制，其中默认为十进制，以0开头的数代表八进制，以0x 或 0X开头的数代表十六进制。
- 整形字面值具体的数据类型由它的值和符号决定。默认情况下，十进制字面值是带符符号的，八进制和十六进制字面值既可能是带符号的也可能是无符号的。
- 默认情况下，十进制字面值的类型为int，八进制和十六进制字面值的类型是能容纳其数值的数据类型中尺寸最小的数据类型。
- 尽管整型字面值可以存储在带符号数据类型中，但十进制字面值不会是负数，如 `-42`字面值中的符号并不在字面值内，他的作用仅仅是对字面值取负而已。
- 浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指数部分用E或e表示：
```
    3.1415925, 3.14E0, 0., .1
```
- 默认情况下浮点型字面值为double，可以通过[后缀](#指定字面值的类型)来表示其他浮点型

##### 字符和字符串字面值
单引号括起来的单个字符被称为字符(char)型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。
```C++
'1'            // 字符字面值
"Hello World"  // 字符串字面值
```
字符串字面值的类型实际上是由常量字符构造成的数组（array），编译器会在每个字符串的结尾处添加一个空字符（'\0'），因此字符串的实际长度要它的内容多1。
```C++
"1"  // 该字符数组由一个 1 与 一个空字符组成。
```
如果一个字符串字面值比较长时可以采取分行书写：
```C++
cout << "这是一个很长的字符串字面值的第一段"
        "这是一个很长的字符串字面值的第二段" << endl;
```
##### 转义序列
C++程序中两类字符是不能直接使用的。
- 第一类是 不可打印（nonprintable）的字符，退格。
- 第二类是 C++语言中的特殊含义字符，如单引号、双引号、问号、反斜线。
   - 在以上情况下，需要时用到转义序列（escape sequence），转义序列以转义符号 `\`开始。
```
换行符 \n，横向制表符 \t，警报符 \a
纵向制表符 \v，退格符 \b，回车符 \r
进纸符 \f, 双引号 \"，单引号 \'
反斜线 \\，问号 \?
```
##### 指定字面值的类型
通过以下所列的前缀和后缀，可以改变整型、浮点型和字符型字面值的默认类型。
```
字符和字符串字面值
前缀 ：
    u Unicode16字符
    U Unicode32字符
    L 宽字符
   u8 UTF-8仅用于字符串字面常量
整型字面值
后缀：
    u or U  无符号
    l or L  长
   ll or LL 长长
浮点型字面值
后缀：
    f or F float
    l or L long double
```
PS： 优先使用 `L` 因为 `l` 与数字1 容易混淆。

##### 布尔字面值和指针字面值
1. ture 和 false 是 布尔类型字面值
2. nullptr 是指针字面值。

#### 变量
- 变量提供了一个可供程序操作的存储空间。在C++中每个变量都有一个数据类型，数据类型决定着变量所占用的内存空间的大小和布局方式与该空间能存储值的范围以及变量能参与的运算。
- 对C++ 程序来说 变量(variable) 和对象(object) 一般可以互换使用。

##### 变量定义
- 语法
`type-specifier variableName[, VariableName, ] [= literal]`
- 例如
```C++
int num;
// 同时定义多个同类型变量
int num2, num3;
// 定义并初赋值。
int num4 = 1;  // 此时我们说这个对象被初始化（initialized）了。
```
初始变量的值可以是任意复杂的表达式。
**注意：初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而复制的含义是吧对象的当前值猜出，而以一个新值来代替。**

##### 列表初始化
```C++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```
当使用内置类型变量时，这种初始化形式有一个重要的特点：如果使用列表初始化且初始化存在丢失信息的风险，则会编译错误。
```C++
long double ld = 3.14;
int t1{ld};  // 编译错误; 错误原因为，使用{}不调用构造函数从而无法进行精度降低、范围变窄等操作。
int t2(ld);  // 编译成功
cout <<  t1 << endl;
```
##### 默认初始化
如果值定义了变量没有指定初始值，则变量会被**默认初始化**（default initialized）。
如 `int a;` ，默认值的值由变量类型决定，同时定义变量的位置 也会对此有影响。
- 值得注意的是，定义函数体内部 的内置类型变量将**不被初始化**（uninitialized）
每个类各自决定其初始化对象的方式，若类的对象没有显示的初始化则值由类确定。

##### 变量声明和定义的关系
C++支持**分离式编译**（separate compilation）机制：该机制允许将程序分割为若干个文件，每个文件可被单独编译。
- 为了支持分离式编程，C++语言将声明与定义分开了。
  - **声明**（declaration）是的名字被程序所知，若一个文件想使用别处定义的名字则必须包含对那个名字的声明。
  - 而**定义**（definition）负责创建于名字关联的实体。
```C++
extern int i;  // 声明i
int j;  //声明并定义j
```
注意：**变量最多只能被定义一次，但可以被声明多次**

##### 标识符
标识符(identifier)由字母、数字和下划线组成，其中必须以字母或者下划线开头；对大小写敏感。同时表示不能与保留字同名。
- 用户自定义的标识符中**不建议**连续出现两个下划线。

- **不建议**在下划线后面紧连大字母起始。

```
按 ISO/IEC 14882:2003 C++ 标准条款 17.4.3.1.2 Global Names [lib.global.names] 规定，包含连续双下划线 "__" 或以下划线 "_" 紧接大写字母起始的标识符保留给（语言和标准库）实现使用。
```

- 定义在函数外面的标识符**不建议**以下划线开头。(In addition, identifiers defined outside a function may not begin with an underscore.)

##### 名字的作用域
同一个名字出现在程序不同的位置，可能指向的不是同一个实体。
- 作用域(scope)
   - C++中大多数的作用域都以花括号`{}`分隔。
   - 名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端结束。
```C++
int main(){
    if(1 < 0){
        int a = 1;
    }  // a 的作用域到此处结束。  
}
// main() 函数没有在任何一个花括号中，它拥有全局作用域（global scope）
// a      它在if{}中，它拥有局部作用域（块作用域）block scope 。
```

##### 嵌套的作用域
作用域能彼此包含，内层的作用域称为**内层作用域**(inner scope)，外层的则被称为**外层作用域**（outer scope）。
- 内层作用域可以访问外层作用域定义的变量。同时也可以更改外层作用域变量的值。
- 使用 `::` **域操作符** 来访问全局变量；因为全局作用域没有名字，所以操作符左侧为空。

注意：**如果函数有可能用到全局变量，则不宜再定义一个同名的局部变量**。

#### 复合类型
**复合类型**（compound type）是指基于其他类型定义的类型。

##### 引用 reference
为对象起名，引用类型应用另一种类型，通过将声明符写成 &d 的形式来定义引用类型，其中d是声明的变量名。
- 一般初始化变量时，初始值会被拷贝到新建的对象中，而引用定义时，则把引用和他的初始值**绑定**（bind）在一起么人不是直接拷贝初始值给引用。所以引用必须要初始化。
注意：**引用必须被初始化**。
- 引用并非对象，相反的，它只是一个已经存在的对象所起的另一个名字，**引用即别名**。
- 引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起；赋值的时候可以。

##### 指针 pointer
指针是指向另外一种类型的复合类型。它可以对其他对象间接访问，但它与引用不同的是，指针本身就是一个对象，允许指针赋值和拷贝。而且在生命周期内它可以先后指向不同的对象。指针无需在定义时赋值，和其他类型一样如果定义不初始化会有一个不确定的值。**不建议这样做，如果不初始化，很危险**

```C++
// 定义指针
int *ptr_int1;  // 野指针，随机指向一个内存地址
int *ptr_int2, int3;  // int3 只是一个int型对象
```

**获取对象地址**
指针存放的是某个对象的地址，若想获取其地址需要使用**&** (取地址符)

```C++
double num = 3.14;
double *ptr_num = &num;
```
注意：**访问无效指针会引发错误，但编译器不负责检查此类错误，顾使用指针应确保自己使用时指针是否有效**

**利用指针访问对象**
如果指针访问了一个对象，则允许使用**解引用符**（`*`）来访问该对象。
```C++
int int1 = 1;
int *ptr_int = &int;
cout << ptr_int << endl;  // 得到int1的内存地址
cout << *ptr_int << endl;  // 1
// 解引用只适用于指向了某个对象的有效指针。
```
**空指针** null pointer
不指向任何对象，使用指针之前代码检查指针是否为空。
```C++
// 设置指针为空的三种方法
int *i1 = nullptr;
int *i2 = 0;

#include <cstdlib>
int *i3 = NULL;
```
建议使用字面值**nullptr**来初始化指针，此方法是C++11引入的方法。它可以转换成其他任意类型的指针类型。也可以设置字面值**0**来初始化生成空指针。

```
int i = 0;
int *p1 = nullptr;
int *p2 = &i;
if (p1) {
    //
}
if (p2) {
    // 任何非0指针都为true
}
```
对于两个类型相同的合法指针，可以用相等操作符(==) 或 不等操作符(!=)来比较他们，比较结果为布尔值。如果两个指针存放的地址相同（都为空；都指向同一个对象；都指向同一个对象的下一个地址），则它们相等；反之则不相等。

**void* 指针**

void是一种特殊的指针类型，可用于存放任意对象的地址。



#### 对象(Object)
通常是指一块能存储数据并具有某种类型的内存空间，
